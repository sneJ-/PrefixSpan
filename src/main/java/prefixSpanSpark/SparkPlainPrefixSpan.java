package prefixSpanSpark;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;

import org.apache.spark.SparkConf;
import org.apache.spark.api.java.JavaRDD;
import org.apache.spark.api.java.JavaSparkContext;
import org.apache.spark.api.java.function.Function;
import org.apache.spark.mllib.fpm.PrefixSpan;
import org.apache.spark.mllib.fpm.PrefixSpan.FreqSequence;
import org.apache.spark.mllib.fpm.PrefixSpanModel;
/**
 * Sparks PrefixSpan implementation for plain input files (i.e. generated by BigBenchInputDecoder or IBM_DataGeneratorInputDecoder)
 * @author Jens Röwekamp
 *
 */
public class SparkPlainPrefixSpan {
	@SuppressWarnings("resource")
	public static void main(String[] args) {
		if (args.length == 3) {
			SparkConf conf = new SparkConf().setAppName("PrefixSpan Plain Example");
			JavaSparkContext sc = new JavaSparkContext(conf);

			JavaRDD<String> rawInput = sc.textFile(args[0]);
			JavaRDD<List<List<Integer>>> sequences = rawInput.map(new PlainInputMapper());
			PrefixSpan prefixSpan = new PrefixSpan().setMinSupport(Double.parseDouble(args[1])).setMaxPatternLength(Integer.parseInt(args[2]));	//With local execution of PrefixSpan
//			PrefixSpan prefixSpan = new PrefixSpan().setMinSupport(Double.parseDouble(args[1])).setMaxPatternLength(Integer.parseInt(args[2])).setMaxLocalProjDBSize(0L); //Without local execution of PrefixSpan
			PrefixSpanModel<Integer> model = prefixSpan.run(sequences);
			List<FreqSequence<Integer>> frequentPatterns = model.freqSequences().toJavaRDD().collect();			
			//sort by frequency DESC
			List<FreqSequence<Integer>> sorted = new LinkedList<FreqSequence<Integer>>(frequentPatterns);
			Collections.sort(sorted, new Comparator<FreqSequence<Integer>>(){
				@Override
				public int compare(FreqSequence<Integer> arg0, FreqSequence<Integer> arg1) {
					if (arg1.freq() > arg0.freq()) return 1;
					else if (arg1.freq() < arg0.freq()) return -1;
					return 0;
				}
			});			
			//output
			for (PrefixSpan.FreqSequence<Integer> freqSeq : sorted) {
				System.out.println(freqSeq.javaSequence() + ", " + freqSeq.freq());
			}
		}
		else{
			System.err.println("ERROR");
			System.err.println("SparkPlainPrefixSpan.jar inputFile minSupport maxPatternLength");
		}
	}
	
	/**
	 * Maps the Flink PrefixSpan input files for Spark usage.
	 * @author Jens Röwekamp
	 *
	 */
	private static class PlainInputMapper implements Function<String,List<List<Integer>>> {
		private static final long serialVersionUID = -982409898264366728L;
		@Override
		public List<List<Integer>> call(String fileLine) throws Exception {
			List<List<Integer>> sequence = new ArrayList<List<Integer>>();
			String[] itemSets = fileLine.split(",0");
			//First entry is the sequence id
			for(int i=1; i<itemSets.length; i++){
				String[] items = itemSets[i].split(",");
				List<Integer> itemSet = new ArrayList<Integer>();
				for(int j=0; j<items.length; j++){
					if(items[j] != null && items[j].length() > 0) itemSet.add(Integer.parseInt(items[j]));
				}
				sequence.add(itemSet);
			}
			return sequence;
		}	
	}
}
